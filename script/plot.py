#!/usr/bin/env python3
"""
Multi-Metric Memory Simulator Results Visualizer

This script creates visualizations from timestamp-specific CSV files generated by the 
memory simulator results gatherer. It can plot multiple metrics in separate graphs.
"""

import os
import argparse
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
from pathlib import Path
import glob
import re

# Define some color palettes for different configuration groups
CONFIG_COLORS = plt.cm.tab20(np.linspace(0, 1, 20))

def find_timestamp_csvs(base_dir):
    """
    Find all timestamp-specific CSV files in the given directory
    
    Args:
        base_dir: Directory containing timestamp CSV files
        
    Returns:
        A dictionary mapping timestamp labels to file paths
    """
    timestamp_files = {}
    
    # Convert to Path object
    base_path = Path(base_dir)
    
    # Look for CSV files with the pattern experiment_YYYYMMDD_HHMMSS.csv
    csv_files = list(base_path.glob("experiment_*.csv"))
    
    for csv_file in csv_files:
        # Extract timestamp from filename
        match = re.search(r'experiment_(\d{8}_\d{6})\.csv', csv_file.name)
        if match:
            timestamp = match.group(1)
            # Format timestamp for better display
            formatted_timestamp = f"{timestamp[0:4]}-{timestamp[4:6]}-{timestamp[6:8]} {timestamp[9:11]}:{timestamp[11:13]}:{timestamp[13:15]}"
            timestamp_files[formatted_timestamp] = csv_file
    
    return timestamp_files

def list_experiment_names(timestamp_files):
    """
    List experiment names for each timestamp file
    
    Args:
        timestamp_files: Dictionary mapping timestamps to file paths
        
    Returns:
        A dictionary mapping timestamps to experiment names
    """
    experiment_names = {}
    
    for timestamp, file_path in timestamp_files.items():
        try:
            # Read just a few rows to extract experiment name
            df = pd.read_csv(file_path, nrows=1)
            if 'experiment_name' in df.columns:
                experiment_names[timestamp] = df['experiment_name'].iloc[0]
            else:
                experiment_names[timestamp] = "Unknown"
        except Exception as e:
            print(f"Error reading experiment name from {file_path}: {e}")
            experiment_names[timestamp] = "Error"
    
    return experiment_names

def load_data(csv_file):
    """
    Load data from a CSV file into a pandas DataFrame
    
    Args:
        csv_file: Path to the CSV file
        
    Returns:
        A pandas DataFrame containing the data
    """
    try:
        df = pd.read_csv(csv_file)
        print(f"Loaded {len(df)} rows from {csv_file}")
        return df
    except Exception as e:
        print(f"Error loading data from {csv_file}: {e}")
        return pd.DataFrame()

def get_unique_values(df, columns):
    """
    Get unique values for specified columns
    
    Args:
        df: pandas DataFrame
        columns: List of column names
        
    Returns:
        A dictionary mapping column names to lists of unique values
    """
    unique_values = {}
    for column in columns:
        if column in df.columns:
            values = sorted(df[column].dropna().unique().tolist())
            unique_values[column] = values
    return unique_values

def filter_data(df, filters):
    """
    Filter DataFrame based on specified filters
    
    Args:
        df: pandas DataFrame
        filters: Dictionary mapping column names to lists of allowed values
        
    Returns:
        A filtered pandas DataFrame
    """
    filtered_df = df.copy()
    for column, values in filters.items():
        if column in filtered_df.columns and values:
            # Convert values to the same type as in the dataframe to avoid comparison issues
            if column == 'toc_enabled':
                # Special handling for toc_enabled which could be boolean or string
                if filtered_df[column].dtype == bool:
                    # Convert string values like 'true'/'false' to boolean
                    bool_values = []
                    for val in values:
                        if isinstance(val, bool):
                            bool_values.append(val)
                        elif isinstance(val, str) and val.lower() == 'true':
                            bool_values.append(True)
                        elif isinstance(val, str) and val.lower() == 'false':
                            bool_values.append(False)
                    filtered_df = filtered_df[filtered_df[column].isin(bool_values)]
                else:
                    # Handle as strings
                    filtered_df = filtered_df[filtered_df[column].isin(values)]
            else:
                filtered_df = filtered_df[filtered_df[column].isin(values)]
    return filtered_df

def get_config_label(row, config_columns):
    """
    Create a label for a configuration based on column values
    
    Args:
        row: pandas Series (a row from the DataFrame)
        config_columns: List of column names to include in the label
        
    Returns:
        A string label for the configuration
    """
    parts = []
    for col in config_columns:
        if col in row and not pd.isna(row[col]):
            # For TOC enabled, use a simpler format
            if col == 'toc_enabled':
                # Handle both boolean and string types
                if isinstance(row[col], bool):
                    parts.append('TOC' if row[col] else 'noTOC')
                else:
                    parts.append('TOC' if str(row[col]).lower() == 'true' else 'noTOC')
            else:
                # Simplify the labels by removing common prefixes and suffixes
                col_label = col.replace('_entries', '').replace('_size', '').replace('_pwc', '')
                parts.append(f"{col_label}={row[col]}")
    return ", ".join(parts)

def create_bar_plot(df, x_column, y_column, config_columns, title=None, output_file=None, 
                   sort_bars=False, fig_size=(14, 8)):
    """
    Create a bar plot with different configurations as bars
    
    Args:
        df: pandas DataFrame
        x_column: Column to use for x-axis (typically 'workload')
        y_column: Column to use for y-axis (the statistic to visualize)
        config_columns: Columns that define a configuration
        title: Plot title
        output_file: Path to save the plot
        sort_bars: Whether to sort bars by y-value
        fig_size: Figure size (width, height) in inches
    """
    if df.empty:
        print("No data to plot")
        return
    
    # Check if columns exist
    if x_column not in df.columns:
        print(f"Error: Column {x_column} not found in data")
        return
    if y_column not in df.columns:
        print(f"Error: Column {y_column} not found in data")
        return
    
    # Create a configuration ID by combining specified columns
    df['config_id'] = df.apply(lambda row: get_config_label(row, config_columns), axis=1)
    
    # Group by x_column and config_id, and calculate the mean of y_column
    grouped = df.groupby([x_column, 'config_id'])[y_column].mean().reset_index()
    
    # Get unique x values and configurations
    x_values = sorted(df[x_column].unique())
    configs = sorted(df['config_id'].unique())
    
    # The number of bars for each x value
    n_configs = len(configs)
    
    # The width of each bar
    bar_width = 0.8 / n_configs
    
    # Set up the figure and axis
    plt.figure(figsize=fig_size)
    ax = plt.subplot(111)
    
    # Plotting
    for i, config in enumerate(configs):
        # Get data for this configuration
        config_data = grouped[grouped['config_id'] == config]
        
        # Sort config_data by y_column if requested
        if sort_bars:
            config_data = config_data.sort_values(by=y_column)
        
        # Calculate x positions for this configuration's bars
        indices = np.arange(len(x_values))
        positions = indices - 0.4 + (i + 0.5) * bar_width
        
        # Values to plot
        values = []
        for x_val in x_values:
            val_row = config_data[config_data[x_column] == x_val]
            if not val_row.empty:
                values.append(val_row[y_column].values[0])
            else:
                values.append(0)
        
        # Plot the bars
        ax.bar(positions, values, bar_width, label=config, color=CONFIG_COLORS[i % len(CONFIG_COLORS)])
    
    # Add labels and title
    ax.set_xlabel(x_column.replace('_', ' ').title())
    ax.set_ylabel(y_column.replace('_', ' ').title())
    if title:
        plt.title(title)
    else:
        plt.title(f'{y_column.replace("_", " ").title()} by {x_column.replace("_", " ").title()}')
    
    # Set y-axis limits for percentage metrics
    if any(term in y_column.lower() for term in ['percentage', 'efficiency', 'hit_rate', 'ratio']):
        ax.set_ylim(0, 100)
    
    # Set x-tick labels
    ax.set_xticks(indices)
    ax.set_xticklabels(x_values, rotation=45, ha='right')
    
    # Add a legend
    if n_configs <= 10:
        # For few configurations, place legend outside
        ax.legend(loc='upper left', bbox_to_anchor=(1, 1))
    else:
        # For many configurations, place legend below
        ax.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15), ncol=3)
    
    # Adjust layout
    plt.tight_layout()
    
    # Save if output_file is specified
    if output_file:
        plt.savefig(output_file, dpi=300, bbox_inches='tight')
        print(f"Saved plot to {output_file}")
    
    # Show the plot
    plt.show()

def create_grouped_bar_plot(df, x_column, y_column, group_column, config_columns, 
                          title=None, output_file=None, fig_size=(14, 8)):
    """
    Create a grouped bar plot with different configurations as groups
    
    Args:
        df: pandas DataFrame
        x_column: Column to use for x-axis (typically 'workload')
        y_column: Column to use for y-axis (the statistic to visualize)
        group_column: Column to use for grouping (e.g., 'toc_enabled')
        config_columns: Columns that define a configuration
        title: Plot title
        output_file: Path to save the plot
        fig_size: Figure size (width, height) in inches
    """
    if df.empty:
        print("No data to plot")
        return
    
    # Check if columns exist
    if x_column not in df.columns:
        print(f"Error: Column {x_column} not found in data")
        return
    if y_column not in df.columns:
        print(f"Error: Column {y_column} not found in data")
        return
    if group_column not in df.columns:
        print(f"Error: Column {group_column} not found in data")
        return
    
    # Create a configuration ID by combining specified columns (excluding the group column)
    config_cols = [col for col in config_columns if col != group_column]
    df['config_id'] = df.apply(lambda row: get_config_label(row, config_cols), axis=1)
    
    # Group by x_column, group_column and config_id, and calculate the mean of y_column
    grouped = df.groupby([x_column, group_column, 'config_id'])[y_column].mean().reset_index()
    
    # Get unique values
    x_values = sorted(df[x_column].unique())
    group_values = sorted(df[group_column].unique())
    configs = sorted(df['config_id'].unique())
    
    # The number of groups
    n_groups = len(group_values)
    
    # The width of each group
    group_width = 0.8 / len(configs)
    
    # Set up the figure and axis
    plt.figure(figsize=fig_size)
    ax = plt.subplot(111)
    
    # Plotting
    for i, config in enumerate(configs):
        # Get data for this configuration
        config_data = grouped[grouped['config_id'] == config]
        
        # Calculate x positions for this configuration's groups
        indices = np.arange(len(x_values))
        
        # Plot each group
        for j, group_val in enumerate(group_values):
            # Get data for this group
            group_data = config_data[config_data[group_column] == group_val]
            
            # Calculate positions for this group's bars
            positions = indices - 0.4 + (i * n_groups + j + 0.5) * (group_width / n_groups)
            
            # Values to plot
            values = []
            for x_val in x_values:
                val_row = group_data[group_data[x_column] == x_val]
                if not val_row.empty:
                    values.append(val_row[y_column].values[0])
                else:
                    values.append(0)
            
            # Label for this group
            if group_column == 'toc_enabled':
                group_label = 'TOC Enabled' if str(group_val).lower() == 'true' else 'TOC Disabled'
            else:
                group_label = f"{group_column}={group_val}"
            
            # Plot the bars
            bar_label = f"{config}, {group_label}"
            ax.bar(positions, values, group_width / n_groups, label=bar_label, 
                  color=CONFIG_COLORS[(i * n_groups + j) % len(CONFIG_COLORS)])
    
    # Add labels and title
    ax.set_xlabel(x_column.replace('_', ' ').title())
    ax.set_ylabel(y_column.replace('_', ' ').title())
    if title:
        plt.title(title)
    else:
        plt.title(f'{y_column.replace("_", " ").title()} by {x_column.replace("_", " ").title()} and {group_column.replace("_", " ").title()}')
    
    # Set y-axis limits for percentage metrics
    if any(term in y_column.lower() for term in ['percentage', 'efficiency', 'hit_rate', 'ratio']):
        ax.set_ylim(0, 100)
    
    # Set x-tick labels
    ax.set_xticks(indices)
    ax.set_xticklabels(x_values, rotation=45, ha='right')
    
    # Add a legend
    if len(configs) * n_groups <= 10:
        # For few configurations, place legend outside
        ax.legend(loc='upper left', bbox_to_anchor=(1, 1))
    else:
        # For many configurations, place legend below
        ax.legend(loc='upper center', bbox_to_anchor=(0.5, -0.15), ncol=3)
    
    # Adjust layout
    plt.tight_layout()
    
    # Save if output_file is specified
    if output_file:
        plt.savefig(output_file, dpi=300, bbox_inches='tight')
        print(f"Saved plot to {output_file}")
    
    # Show the plot
    plt.show()

def create_heatmap(df, x_column, y_column, value_column, title=None, output_file=None, fig_size=(14, 10)):
    """
    Create a heatmap visualization
    
    Args:
        df: pandas DataFrame
        x_column: Column to use for x-axis
        y_column: Column to use for y-axis
        value_column: Column to use for cell values
        title: Plot title
        output_file: Path to save the plot
        fig_size: Figure size (width, height) in inches
    """
    if df.empty:
        print("No data to plot")
        return
    
    # Check if columns exist
    if x_column not in df.columns:
        print(f"Error: Column {x_column} not found in data")
        return
    if y_column not in df.columns:
        print(f"Error: Column {y_column} not found in data")
        return
    if value_column not in df.columns:
        print(f"Error: Column {value_column} not found in data")
        return
    
    # Group by x and y columns and calculate the mean of the value column
    pivoted = df.pivot_table(index=y_column, columns=x_column, values=value_column, aggfunc='mean')
    
    # Set up the figure
    plt.figure(figsize=fig_size)
    
    # Check if the value column is a percentage
    is_percentage = any(term in value_column.lower() for term in ['percentage', 'efficiency', 'hit_rate', 'ratio'])
    
    # Create the heatmap with appropriate vmin/vmax for percentages
    if is_percentage:
        sns.heatmap(pivoted, annot=True, cmap='YlGnBu', fmt='.2f', linewidths=0.5, vmin=0, vmax=100)
    else:
        sns.heatmap(pivoted, annot=True, cmap='YlGnBu', fmt='.2f', linewidths=0.5)
    
    # Add title
    if title:
        plt.title(title)
    else:
        plt.title(f'{value_column.replace("_", " ").title()} by {x_column.replace("_", " ").title()} and {y_column.replace("_", " ").title()}')
    
    # Adjust layout
    plt.tight_layout()
    
    # Save if output_file is specified
    if output_file:
        plt.savefig(output_file, dpi=300, bbox_inches='tight')
        print(f"Saved plot to {output_file}")
    
    # Show the plot
    plt.show()

def interactive_timestamp_selection(timestamp_files, experiment_names):
    """
    Interactive selection of timestamp(s) to visualize
    
    Args:
        timestamp_files: Dictionary mapping timestamps to file paths
        experiment_names: Dictionary mapping timestamps to experiment names
        
    Returns:
        List of selected timestamp keys
    """
    print("\n=== Available Timestamp Experiments ===")
    timestamps = list(timestamp_files.keys())
    
    for i, timestamp in enumerate(timestamps, 1):
        exp_name = experiment_names.get(timestamp, "Unknown")
        print(f"{i}. {timestamp} - {exp_name}")
    
    print("\nSelect timestamp(s) to visualize (separated by spaces, e.g., '1 3 5'), or 'all' for all:")
    selection = input().strip()
    
    if selection.lower() == 'all':
        return timestamps
    
    try:
        indices = [int(idx) for idx in selection.split()]
        selected_timestamps = [timestamps[idx-1] for idx in indices if 1 <= idx <= len(timestamps)]
        return selected_timestamps
    except (ValueError, IndexError):
        print("Invalid selection. Using the first timestamp.")
        return [timestamps[0]] if timestamps else []

def interactive_metric_selection(metric_columns):
    """
    Interactive selection of metric(s) to visualize
    
    Args:
        metric_columns: List of available metric columns
        
    Returns:
        List of selected metric columns
    """
    print("\n=== Y-Axis Metric Selection ===")
    print("You can select multiple metrics to create multiple plots")
    for i, col in enumerate(metric_columns, 1):
        print(f"{i}. {col}")
    
    print("\nSelect metric(s) to visualize (separated by spaces, e.g., '1 3 5'):")
    selection = input().strip()
    
    try:
        indices = [int(idx) for idx in selection.split()]
        selected_metrics = [metric_columns[idx-1] for idx in indices if 1 <= idx <= len(metric_columns)]
        if not selected_metrics:
            print("Invalid selection. Using the first metric.")
            return [metric_columns[0]] if metric_columns else []
        return selected_metrics
    except (ValueError, IndexError):
        print("Invalid selection. Using the first metric.")
        return [metric_columns[0]] if metric_columns else []

def interactive_mode(timestamp_files, experiment_names):
    """
    Run in interactive mode, allowing user to select options
    
    Args:
        timestamp_files: Dictionary mapping timestamps to file paths
        experiment_names: Dictionary mapping timestamps to experiment names
        
    Returns:
        Dictionary with plotting options and selected timestamps
    """
    # Select timestamps
    selected_timestamps = interactive_timestamp_selection(timestamp_files, experiment_names)
    
    if not selected_timestamps:
        print("No timestamps selected. Exiting.")
        return None
    
    # Load the first selected timestamp to get column information
    first_file = timestamp_files[selected_timestamps[0]]
    df = load_data(first_file)
    
    if df.empty:
        print(f"Error loading data from {first_file}. Exiting.")
        return None
    
    # Fill missing TOC values with defaults
    if 'toc_enabled' in df.columns:
        df['toc_enabled'] = df['toc_enabled'].fillna(False)
    if 'toc_size' in df.columns:
        df['toc_size'] = df['toc_size'].fillna(0)
    
    # Get available columns and their unique values
    config_columns = ['pgd_size', 'pud_size', 'pmd_size', 'pte_size', 
                     'pgd_pwc_entries', 'pud_pwc_entries', 'pmd_pwc_entries', 
                     'toc_enabled', 'toc_size']
    
    metric_columns = [col for col in df.columns if any(x in col for x in 
                                                   ['hit', 'miss', 'efficiency', 'accesses', 'cost', 'avg'])]
    
    # Sort columns by name for better display
    metric_columns.sort()
    
    # Get unique values for config columns
    unique_values = get_unique_values(df, config_columns + ['workload'])
    
    # Plot type selection
    print("\n=== Plot Type Selection ===")
    print("1. Bar Plot (configurations as separate bars)")
    print("2. Grouped Bar Plot (configurations grouped by a column)")
    print("3. Heatmap (configurations as a matrix)")
    
    while True:
        try:
            plot_type_choice = int(input("Enter your choice (1-3): "))
            if 1 <= plot_type_choice <= 3:
                break
            print("Invalid choice. Please enter a number between 1 and 3.")
        except ValueError:
            print("Invalid input. Please enter a number.")
    
    plot_types = ['bar', 'grouped', 'heatmap']
    plot_type = plot_types[plot_type_choice - 1]
    
    # X-axis selection
    print("\n=== X-Axis Selection ===")
    print("1. Workload")
    print("2. Another column")
    
    while True:
        try:
            x_choice = int(input("Enter your choice (1-2): "))
            if 1 <= x_choice <= 2:
                break
            print("Invalid choice. Please enter a number between 1 and 2.")
        except ValueError:
            print("Invalid input. Please enter a number.")
    
    if x_choice == 1:
        x_column = 'workload'
    else:
        print("\nAvailable columns:")
        for i, col in enumerate(config_columns, 1):
            print(f"{i}. {col}")
        
        while True:
            try:
                col_choice = int(input("Enter column number: "))
                if 1 <= col_choice <= len(config_columns):
                    x_column = config_columns[col_choice - 1]
                    break
                print(f"Invalid choice. Please enter a number between 1 and {len(config_columns)}.")
            except ValueError:
                print("Invalid input. Please enter a number.")
    
    # Y-axis (metric) selection - MODIFIED to support multiple metrics
    y_columns = interactive_metric_selection(metric_columns)
    
    # For grouped bar plots, select group column
    group_column = None
    if plot_type == 'grouped':
        print("\n=== Group Column Selection ===")
        for i, col in enumerate(config_columns, 1):
            print(f"{i}. {col}")
        
        while True:
            try:
                group_choice = int(input(f"Enter your choice (1-{len(config_columns)}): "))
                if 1 <= group_choice <= len(config_columns):
                    group_column = config_columns[group_choice - 1]
                    break
                print(f"Invalid choice. Please enter a number between 1 and {len(config_columns)}.")
            except ValueError:
                print("Invalid input. Please enter a number.")
    
    # Configuration columns selection - Commented out
    # print("\n=== Configuration Columns Selection ===")
    # print("Select which columns define a configuration (separated by spaces, e.g., '1 3 5'):")
    # for i, col in enumerate(config_columns, 1):
    #     print(f"{i}. {col}")
    
    # while True:
    #     try:
    #         config_choices = input("Enter your choices: ").split()
    #         config_choices = [int(choice) for choice in config_choices]
    #         if all(1 <= choice <= len(config_columns) for choice in config_choices):
    #             selected_config_columns = [config_columns[choice - 1] for choice in config_choices]
    #             break
    #         print(f"Invalid choices. Please enter numbers between 1 and {len(config_columns)}.")
    #     except ValueError:
    #         print("Invalid input. Please enter numbers separated by spaces.")
    selected_config_columns = config_columns  # Use all columns by default

    # Filter selection
    filters = {}
    print("\n=== Filter Selection ===")
    print("Would you like to apply filters? (y/n)")
    filter_choice = input().lower()
    
    if filter_choice == 'y':
        # For each column with unique values, ask about filtering
        for col, values in unique_values.items():
            if len(values) > 1:  # Only ask if there are multiple values
                print(f"\nAvailable values for {col}:")
                for i, val in enumerate(values, 1):
                    print(f"{i}. {val}")
                
                print("Enter the numbers of values to include (separated by spaces), or press Enter for all:")
                filter_input = input().strip()
                
                if filter_input:
                    try:
                        filter_choices = [int(choice) for choice in filter_input.split()]
                        if all(1 <= choice <= len(values) for choice in filter_choices):
                            filters[col] = [values[choice - 1] for choice in filter_choices]
                        else:
                            print(f"Invalid choices. Including all values for {col}.")
                    except ValueError:
                        print(f"Invalid input. Including all values for {col}.")
    
    # Sort option
    print("\n=== Sort Option ===")
    print("Sort bars by y-value? (y/n)")
    sort_choice = input().lower()
    sort_bars = sort_choice == 'y'
    
    # Output file option
    print("\n=== Output File ===")
    print("Save plots to files? (y/n)")
    save_choice = input().lower()
    
    output_dir = None
    if save_choice == 'y':
        print("Enter output directory (default: 'plots'):")
        output_dir = input().strip()
        if not output_dir:
            output_dir = 'plots'
        
        # Create the directory if it doesn't exist
        os.makedirs(output_dir, exist_ok=True)
    
    # Create options dictionary with default config_columns
    options = {
        'selected_timestamps': selected_timestamps,
        'plot_type': plot_type,
        'x_column': x_column,
        'y_columns': y_columns,  # Now a list of columns
        'group_column': group_column,
        'config_columns': selected_config_columns,
        'filters': filters,
        'sort_bars': sort_bars,
        'output_dir': output_dir
    }
    
    return options

def parse_args():
    """Parse command line arguments"""
    parser = argparse.ArgumentParser(description='Visualize timestamp-based memory simulator results')
    parser.add_argument('-d', '--input_dir', type=str, required=True,
                        help='Directory containing timestamp-specific CSV files')
    parser.add_argument('-o', '--output_dir', type=str, default='plots',
                        help='Directory to save the plots')
    parser.add_argument('-t', '--plot_type', type=str, choices=['bar', 'grouped', 'heatmap'], default='bar',
                        help='Type of plot to generate')
    parser.add_argument('-x', '--x_column', type=str, default='workload',
                        help='Column to use for x-axis')
    parser.add_argument('-y', '--y_columns', type=str, nargs='+',
                        default=['l1_tlb_hit_percentage'],
                        help='Column(s) to use for y-axis (the statistic(s) to visualize)')
    parser.add_argument('-g', '--group_column', type=str, default='toc_enabled',
                        help='Column to use for grouping (only for grouped bar plots)')
    # Commented out config_columns argument
    # parser.add_argument('-c', '--config_columns', type=str, nargs='+',
    #                    default=['pgd_size', 'pud_size', 'pmd_size', 'pte_size', 
    #                            'pgd_pwc_entries', 'pud_pwc_entries', 'pmd_pwc_entries', 
    #                            'toc_enabled', 'toc_size'],
    #                    help='Columns that define a configuration')
    parser.add_argument('-s', '--sort', action='store_true',
                        help='Sort bars by y-value')
    parser.add_argument('--timestamp', type=str, nargs='+',
                        help='Specific timestamp(s) to visualize (format: YYYYMMDD_HHMMSS)')
    parser.add_argument('--list_timestamps', action='store_true',
                        help='List available timestamp experiments and exit')
    parser.add_argument('--interactive', action='store_true',
                        help='Enable interactive mode for selecting plotting options')
    
    return parser.parse_args()

def main():
    """Main function"""
    args = parse_args()
    
    # Find timestamp-specific CSV files
    timestamp_files = find_timestamp_csvs(args.input_dir)
    
    if not timestamp_files:
        print(f"No timestamp-specific CSV files found in {args.input_dir}")
        print("Expected file pattern: experiment_YYYYMMDD_HHMMSS.csv")
        return
    
    # Get experiment names for each timestamp
    experiment_names = list_experiment_names(timestamp_files)
    
    # If requested, list available timestamps and exit
    if args.list_timestamps:
        print("\nAvailable timestamp experiments:")
        for i, (timestamp, file_path) in enumerate(timestamp_files.items(), 1):
            exp_name = experiment_names.get(timestamp, "Unknown")
            print(f"{i}. {timestamp} - {exp_name} ({file_path})")
        return
    
    # Define default configuration columns
    config_columns = ['pgd_size', 'pud_size', 'pmd_size', 'pte_size', 
                     'pgd_pwc_entries', 'pud_pwc_entries', 'pmd_pwc_entries', 
                     'toc_enabled', 'toc_size']
    
    # If interactive mode is enabled, get options from user
    if args.interactive:
        options = interactive_mode(timestamp_files, experiment_names)
        if not options:
            return
        
        selected_timestamps = options['selected_timestamps']
        plot_type = options['plot_type']
        x_column = options['x_column']
        y_columns = options['y_columns']  # Now a list of columns
        group_column = options['group_column']
        config_columns = options['config_columns']  # Commented out
        filters = options['filters']
        sort_bars = options['sort_bars']
        output_dir = options['output_dir']
    else:
        # Use command line arguments
        # Select timestamps
        if args.timestamp:
            # Find matching timestamps
            selected_timestamps = []
            for timestamp in timestamp_files.keys():
                # Extract the raw timestamp part for comparison
                timestamp_raw = timestamp.replace('-', '').replace(' ', '_').replace(':', '')
                if any(t in timestamp_raw for t in args.timestamp):
                    selected_timestamps.append(timestamp)
        else:
            # Use all timestamps
            selected_timestamps = list(timestamp_files.keys())
        
        plot_type = args.plot_type
        x_column = args.x_column
        y_columns = args.y_columns  # Now a list of columns
        group_column = args.group_column
        config_columns = args.config_columns  # Commented out
        filters = {}
        sort_bars = args.sort
        output_dir = args.output_dir
    
    # Create output directory if specified
    if output_dir:
        os.makedirs(output_dir, exist_ok=True)
    
    # Process each selected timestamp
    for timestamp in selected_timestamps:
        file_path = timestamp_files[timestamp]
        exp_name = experiment_names.get(timestamp, "Unknown")
        
        print(f"\nProcessing: {timestamp} - {exp_name}")
        
        # Load data
        df = load_data(file_path)
        if df.empty:
            continue
        
        # Fill missing TOC values with defaults
        if 'toc_enabled' in df.columns:
            df['toc_enabled'] = df['toc_enabled'].fillna(False)
        if 'toc_size' in df.columns:
            df['toc_size'] = df['toc_size'].fillna(0)
        
        # Apply filters
        filtered_df = filter_data(df, filters)
        
        # Format timestamp for filename
        ts_filename = timestamp.replace('-', '').replace(' ', '_').replace(':', '')
        
        # Process each selected y-column (metric)
        for y_column in y_columns:
            if y_column not in filtered_df.columns:
                print(f"Warning: Column {y_column} not found in data, skipping")
                continue
            
            print(f"Creating plot for metric: {y_column}")
            
            # Create output filename
            if output_dir:
                base_filename = f"{plot_type}_{ts_filename}_{x_column}_{y_column}.png"
                output_file = os.path.join(output_dir, base_filename)
            else:
                output_file = None
            
            # Create title with timestamp, experiment name, and metric
            title = f"{exp_name} - {timestamp} - {y_column.replace('_', ' ').title()} by {x_column.replace('_', ' ').title()}"
            
            # Create plot based on selected type
            if plot_type == 'bar':
                create_bar_plot(
                    filtered_df,
                    x_column,
                    y_column,
                    config_columns,  # Using the default config_columns
                    title=title,
                    output_file=output_file,
                    sort_bars=sort_bars
                )
            elif plot_type == 'grouped':
                create_grouped_bar_plot(
                    filtered_df,
                    x_column,
                    y_column,
                    group_column,
                    config_columns,  # Using the default config_columns
                    title=title,
                    output_file=output_file
                )
            elif plot_type == 'heatmap':
                create_heatmap(
                    filtered_df,
                    x_column,
                    y_column,
                    config_columns[0] if config_columns else 'pgd_size',
                    title=title,
                    output_file=output_file
                )

if __name__ == "__main__":
    main()